{"mappings":"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","sources":["src/make-error.ts","src/type-by-example.ts"],"sourcesContent":["const stringify = (x: any): string => {\n  try {\n    return JSON.stringify(x)\n  } catch (_) {\n    return '{has circular references}'\n  }\n}\n\nexport const makeError = (...messages: any[]): Error => new Error(messages.map(stringify).join(' '))\n","import { makeError } from './make-error'\n\nexport interface StringMap {\n  [key: string]: string | number | StringMap | any[] | Function\n}\n\nconst asyncFunc = async (): Promise<void> => {}\nexport const isAsync = (func: Function): boolean => func.constructor === (asyncFunc).constructor\n\nexport const describe = (x: any): string => {\n  if (x === null) return 'null'\n  if (Array.isArray(x)) return 'array'\n  if (typeof x === 'number') {\n    if (isNaN(x)) return 'NaN'\n  }\n  if (typeof x === 'string' && x.startsWith('#')) return x\n  if (x instanceof Promise) return 'promise'\n  if (typeof x === 'function') {\n    return x.constructor === (async () => {}).constructor\n      ? 'async'\n      : 'function'\n  }\n  if (typeof x === 'object' && x.constructor.name !== 'Object') {\n    return x.constructor.name\n  }\n  return typeof x\n}\n\n// FIXME: bun doesn't handle unicode characters in code correctly\n// should be able to replace \\u221E with âˆž\nconst parseFloatOrInfinity = (x: string): number => {\n  if (x === '-\\u221E') {\n    return -Infinity\n  } else if (x[0] === '\\u221E') {\n    return Infinity\n  } else {\n    return parseFloat(x)\n  }\n}\n\nconst inRange = (spec: string, x: number): boolean => {\n  let lower: string, upper: string\n  if (spec === undefined) return true\n  try {\n    // @ts-expect-error\n    [, lower, upper] = spec.match(/^([[(]-?[\\d.\\u221E]+)?,?(-?[\\d.\\u221E]+[\\])])?$/)\n  } catch (e) {\n    throw new Error(`bad range ${spec}`)\n  }\n  if (lower !== undefined && lower !== '') {\n    const min = parseFloatOrInfinity(lower.substring(1))\n    if (lower[0] === '(') {\n      if (x <= min) return false\n    } else {\n      if (x < min) return false\n    }\n  }\n  if (upper !== undefined && upper !== '') {\n    const max = parseFloatOrInfinity(upper)\n    if (upper.endsWith(')')) {\n      if (x >= max) return false\n    } else {\n      if (x > max) return false\n    }\n  }\n  return true\n}\n\nconst regExps: { [key: string]: RegExp } = {}\n\nconst regexpTest = (spec: string, subject: any): boolean => {\n  const regexp = regExps[spec] !== undefined ? regExps[spec] : regExps[spec] = new RegExp(spec)\n  return regexp.test(subject)\n}\n\nexport const isInstanceOf = (obj: any, constructor: string | Function): boolean => {\n  if (typeof constructor === 'function') {\n    return obj instanceof Function\n  } else {\n    let proto = Object.getPrototypeOf(obj)\n    while (proto.constructor !== undefined && proto.constructor !== Object) {\n      if (proto.constructor.name === constructor) {\n        return true\n      }\n      proto = Object.getPrototypeOf(proto)\n    }\n    return false\n  }\n}\n\nexport const specificTypeMatch = (type: any, subject: any): boolean => {\n  // eslint-disable-next-line\n  const [, optional, baseType, , spec] = type.match(/^#([?]?)([^\\s]+)(\\s(.*))?$/) || []\n  if (optional !== '' && (subject === null || subject === undefined)) return true\n  const subjectType = describe(subject)\n  switch (baseType) {\n    case 'forbidden':\n      return false\n    case 'any':\n      return subject !== null && subject !== undefined\n    case 'native':\n      if (typeof subject !== 'function' || subject.toString() !== 'function () { [native code] }') {\n        return false\n      }\n      if (type == null) {\n        return true\n      }\n      return isAsync(subject) ? type.match(/^async\\b/) : type.match(/^function\\b/)\n    case 'function':\n      if (subjectType !== 'function') return false\n      // todo allow for typeSafe functions with param/result specified by name\n      return true\n    case 'number':\n      if (subjectType !== 'number') return false\n      return inRange(spec, subject)\n    case 'int':\n      if (subjectType !== 'number' || subject !== Math.floor(subject)) return false\n      return inRange(spec, subject)\n    case 'union':\n      return spec.split('||').find((type: string) => specificTypeMatch(`#${type}`, subject)) !== undefined\n    case 'enum':\n      try {\n        return spec.split('|').map(JSON.parse).includes(subject)\n      } catch (e) {\n        throw new Error(`bad enum specification (${spec as string}), expect JSON strings`)\n      }\n    case 'void':\n      return subjectType === 'undefined' || subjectType === 'null'\n    case 'nothing':\n      return subjectType === 'undefined'\n    case 'string':\n      return subjectType === 'string'\n    case 'regexp':\n      return subjectType === 'string' && regexpTest(spec, subject)\n    case 'array':\n      return Array.isArray(subject)\n    case 'instance':\n      return isInstanceOf(subject, spec)\n    case 'promise':\n      return subject instanceof Promise\n    case 'object':\n      return (subject !== null) && typeof subject === 'object' && !Array.isArray(subject)\n    default:\n      if (subjectType !== baseType) {\n        throw makeError('got', subject, `expected \"${type as string}\", \"${subjectType}\" does not match \"${baseType as string}\"`)\n      } else {\n        return true\n      }\n  }\n}\n\nconst functionDeclaration = /^((async\\s+)?function)?\\s*\\((.*?)\\)\\s*(=>)?\\s*\\{/\nconst arrowDeclaration = /^((\\.\\.\\.\\w+)|(\\w+)|\\((.*?)\\))\\s*=>\\s*[^\\s{]/\nconst returnsValue = /\\w+\\s*=>\\s*[^\\s{]|\\breturn\\b/\n\nexport const describeType = (x: any): StringMap | string => {\n  const scalarType = describe(x)\n  switch (scalarType) {\n    case 'array':\n      return x.map(describeType)\n    case 'object':\n      if (x.constructor === Object) {\n        const _type: StringMap = {}\n        Object.keys(x as StringMap).forEach((key) => { _type[key] = describeType(x[key]) })\n        return _type\n      } else {\n        return '#instance x.constructor.name'\n      }\n    case 'function':\n    case 'async':\n    {\n      if (x.protoype !== undefined) {\n        return '#class x.name'\n      }\n      const source = (x as Function).toString()\n      if (source.endsWith('() { [native code] }')) {\n        return `#native ${scalarType}`\n      }\n      const functionSource = source.match(functionDeclaration)\n      const arrowSource = source.match(arrowDeclaration)\n      const hasReturnValue = (source.match(returnsValue) != null) || source.match(arrowDeclaration)\n\n      // eslint-disable-next-line\n      const paramText = ((functionSource && functionSource[3]) ||\n          // eslint-disable-next-line\n          (arrowSource && (arrowSource[2] || arrowSource[3] || arrowSource[4])) || '').trim()\n      const params = paramText.split(',').map((param: string) => {\n        const [key] = param.split('=')\n        return `${key} #any`\n      })\n      return `${scalarType} ( ${params.join(', ')} ) => ${(hasReturnValue != null) ? '#any' : '#nothing'}`\n    }\n    default:\n      return `#${scalarType}`\n  }\n}\n\nexport const typeJSON = (x: any): string => JSON.stringify(describeType(x))\nexport const typeJS = (x: any): string => typeJSON(x).replace(/\"(\\w+)\":/g, '$1:')\n\nconst quoteIfString = (x: any): string => typeof x === 'string' ? `\"${x}\"` : (typeof x === 'object' ? describe(x) : x)\n\n// when checking large arrays, only check a maximum of 111 elements\nfunction * arraySampler (a: any[]): any {\n  let i = 0\n  // 101 is a prime number so hopefully we'll avoid sampling fixed patterns\n  const increment = Math.ceil(a.length / 101)\n  while (i < a.length) {\n    // first five\n    if (i < 5) {\n      yield { sample: a[i], i }\n      i++\n    // last five\n    } else if (i > a.length - 5) {\n      yield { sample: a[i], i }\n      i++\n    } else {\n    // ~1% of the ones in the middle\n      yield { sample: a[i], i }\n      i = Math.min(i + increment, a.length - 4)\n    }\n  }\n}\n\nexport const matchType = (example: any, subject: any, errors: string[] = [], path = ''): string[] => {\n  const exampleType = describe(example)\n  const subjectType = describe(subject)\n  const typesMatch = exampleType.startsWith('#')\n    ? specificTypeMatch(exampleType, subject)\n    : exampleType === subjectType\n  if (!typesMatch) {\n    errors.push(`${path !== '' ? path + ' ' : ''}was ${quoteIfString(subject)}, expected ${exampleType}`)\n  } else if (exampleType === 'array') {\n    // only checking first element of subject for now\n    const sampler = subject.length > 0 ? arraySampler(subject) : false\n    if (example.length === 1 && sampler !== false) {\n      // assume homogenous array\n      for (const { sample, i } of sampler) matchType(example[0], sample, errors, `${path}[${i as number}]`)\n    } else if (example.length > 1 && sampler !== false) {\n      // assume heterogeneous array\n      for (const { sample, i } of sampler) {\n        let foundMatch = false\n        for (const specificExample of example) {\n          if (matchType(specificExample, sample, [], '').length === 0) {\n            foundMatch = true\n            break\n          }\n        }\n        if (!foundMatch) errors.push(`${path}[${i as number}] had no matching type`)\n      }\n    }\n  } else if (exampleType === 'object') {\n    matchKeys(example, subject, errors, path)\n  }\n  return errors\n}\n\nexport const exampleAtPath = (example: any, path: string | string[]): any => {\n  const parts = Array.isArray(path)\n    ? [...path]\n    : path.replace(/\\[[^\\]]*\\]/g, '.*').split('.')\n  if (example === null || example === undefined || parts.length === 0) {\n    return example\n  } else {\n    const part = parts.shift()\n    if (part === '*') {\n      if (Array.isArray(example)) {\n        return example.length === 1\n          ? exampleAtPath(example[0], parts)\n          : exampleAtPath(Object.assign({}, ...example), parts)\n      } else {\n        return undefined\n      }\n    } else {\n      // @ts-expect-error\n      return exampleAtPath(example[part], parts)\n    }\n  }\n}\n\nconst legalVarName = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/\nconst matchKeys = (example: any, subject: any, errors: string[] = [], path = ''): string[] => {\n  const testedKeys = new Set()\n  for (const key of Object.keys(example)) {\n    if (key.startsWith('#')) {\n      let keyTest = legalVarName\n      try {\n        if (key !== '#') {\n          keyTest = new RegExp(`^${key.substring(1)}$`)\n        }\n      } catch (e) {\n        const badKeyError = `illegal regular expression in example key '${key}'`\n        errors.push(badKeyError)\n        throw makeError(badKeyError)\n      }\n      const matchingKeys = Object.keys(subject).filter(key => keyTest.test(key))\n      for (const k of matchingKeys) {\n        if (!testedKeys.has(k)) {\n          matchType(example[key], subject[k], errors, `${path}./^${key.substring(1)}$/:${k}`)\n          testedKeys.add(k)\n        }\n      }\n    } else if (key.endsWith('?')) {\n      const k = key.slice(0, key.length - 1)\n      if (Object.hasOwnProperty.call(subject, k)) {\n        if (!testedKeys.has(k)) {\n          matchType(example[key], subject[k], errors, path + '.' + k)\n          testedKeys.add(k)\n        }\n      }\n    } else {\n      if (!testedKeys.has(key)) {\n        matchType(example[key], subject[key], errors, path + '.' + key)\n        testedKeys.add(key)\n      }\n    }\n  }\n  return errors\n}\n\ninterface TypeErrorConfig {\n  functionName?: string\n  isParamFailure: boolean\n  expected: any\n  found: any\n  errors: string[]\n}\n\nexport class TypeError {\n  // initializers are unnecessary but TypeScript is too stupid\n  functionName: string = 'anonymous'\n  isParamFailure: boolean = false\n  expected: any\n  found: any\n  errors: string[] = []\n\n  constructor (config: TypeErrorConfig) {\n    Object.assign(this, config)\n  }\n\n  toString (): string {\n    const {\n      functionName,\n      isParamFailure,\n      errors\n    } = this\n    return `${functionName}() failed, bad ${isParamFailure ? 'parameter' : 'return'}: ${JSON.stringify(errors)}`\n  }\n}\n\nexport const assignReadOnly = (obj: any, propMap: StringMap): any => {\n  propMap = { ...propMap }\n  for (const key of Object.keys(propMap)) {\n    const value = propMap[key]\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      get () {\n        return value\n      },\n      set (value) {\n        throw new Error(`${key} is read-only`)\n      }\n    })\n  }\n  return obj\n}\n\nexport const matchParamTypes = (types: any[], params: any[]): string[] => {\n  for (let i = 0; i < params.length; i++) {\n    if (params[i] instanceof TypeError) {\n      return params[i]\n    }\n  }\n  const [paramErrors, returnErrors] = types.map((type, i) => matchType(type, params[i]))\n  return [...paramErrors, ...returnErrors]\n}\n\ninterface TypeSafeFunction {\n  (...args: any[]): any\n  paramTypes: any[]\n  resultType: any\n}\n\nexport const typeSafe = (func: Function, paramTypes: any[] = [], resultType: any = undefined, functionName: string = 'anonymous'): TypeSafeFunction => {\n  const paramErrors = matchParamTypes(\n    ['#function', '#?array', '#?any', '#?string'],\n    [func, paramTypes, resultType, functionName]\n  )\n  if (paramErrors instanceof TypeError) {\n    throw new Error('typeSafe was passed bad parameters')\n  }\n\n  if (func.name !== '') {\n    functionName = func.name\n  }\n  let callCount = 0\n  return assignReadOnly(function (...params: any[]) {\n    callCount += 1\n    const paramErrors = matchParamTypes(paramTypes, params)\n    // short circuit failures\n    if (paramErrors instanceof TypeError) return paramErrors\n\n    if (paramErrors.length === 0) {\n      const result = func(...params)\n      const resultErrors = matchType(resultType, result)\n      if (resultErrors.length === 0) {\n        return result\n      } else {\n        return new TypeError({\n          functionName,\n          isParamFailure: false,\n          expected: resultType,\n          found: result,\n          errors: resultErrors\n        })\n      }\n    }\n    return new TypeError({\n      functionName,\n      isParamFailure: true,\n      expected: paramTypes,\n      found: params,\n      errors: paramErrors\n    })\n  }, {\n    paramTypes,\n    resultType,\n    getCallCount: () => callCount\n  })\n}\n"],"names":["$9c8ee0b1e1b7d62b$var$stringify","x","JSON","stringify","_","$9c8ee0b1e1b7d62b$export$5a4bb2b1c89bdce7","messages","Error","map","join","$13e46a4dcb71aaed$var$asyncFunc","async","$13e46a4dcb71aaed$export$aefee5ebe1dcfd9e","func","constructor","$13e46a4dcb71aaed$export$cd5450f3a47e3789","Array","isArray","isNaN","startsWith","Promise","name","$13e46a4dcb71aaed$var$parseFloatOrInfinity","Infinity","parseFloat","$13e46a4dcb71aaed$var$inRange","spec","lower","upper","undefined","match","e","min","substring","max","endsWith","$13e46a4dcb71aaed$var$regExps","$13e46a4dcb71aaed$export$49034edbe6b62415","obj","Function","proto","Object","getPrototypeOf","$13e46a4dcb71aaed$export$afac8cfc87e341d0","type","subject","optional","baseType","subjectType","toString","Math","floor","split","find","parse","includes","RegExp","test","$13e46a4dcb71aaed$var$regexpTest","$13e46a4dcb71aaed$var$functionDeclaration","$13e46a4dcb71aaed$var$arrowDeclaration","$13e46a4dcb71aaed$var$returnsValue","$13e46a4dcb71aaed$export$b84ab2ad77da7adc","scalarType","_type","keys","forEach","key","protoype","source","functionSource","arrowSource","hasReturnValue","trim","param","$13e46a4dcb71aaed$export$b3b9d0693605ef8b","$13e46a4dcb71aaed$export$518decae858c583a","replace","$13e46a4dcb71aaed$export$a71efb50630d6710","example","errors","path","exampleType","sampler","length","a","i","increment","ceil","sample","$13e46a4dcb71aaed$var$arraySampler","foundMatch","specificExample","push","$13e46a4dcb71aaed$var$matchKeys","$13e46a4dcb71aaed$export$4ac0c519b1a9e80e","parts","part","shift","assign","$13e46a4dcb71aaed$var$legalVarName","testedKeys","Set","keyTest","badKeyError","matchingKeys","filter","k","has","add","slice","hasOwnProperty","call","$13e46a4dcb71aaed$export$f1c4b559ff572cce","functionName","isParamFailure","config","this","$13e46a4dcb71aaed$export$a3a0906114eec376","propMap","value","defineProperty","enumerable","get","set","$13e46a4dcb71aaed$export$416306c82e0f43c5","types","params","paramErrors","returnErrors","$13e46a4dcb71aaed$export$de5257c629b5bb7d","paramTypes","resultType","callCount","result","resultErrors","expected","found","getCallCount"],"version":3,"file":"index.js.map"}