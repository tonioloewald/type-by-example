{"mappings":"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","sources":["src/index.ts","src/type-by-example.ts","src/make-error.ts"],"sourcesContent":["export * from './type-by-example'\n","import { makeError } from './make-error'\n\nexport interface StringMap {\n  [key: string]: string | number | StringMap | any[] | Function\n}\n\nconst asyncFunc = async (): Promise<void> => {}\nexport const isAsync = (func: Function): boolean => func.constructor === (asyncFunc).constructor\n\nexport const describe = (x: any): string => {\n  if (x === null) return 'null'\n  if (Array.isArray(x)) return 'array'\n  if (typeof x === 'number') {\n    if (isNaN(x)) return 'NaN'\n  }\n  if (typeof x === 'string' && x.startsWith('#')) return x\n  if (x instanceof Promise) return 'promise'\n  if (typeof x === 'function') {\n    return x.constructor === (async () => {}).constructor\n      ? 'async'\n      : 'function'\n  }\n  if (typeof x === 'object' && x.constructor.name !== 'Object') {\n    return x.constructor.name\n  }\n  return typeof x\n}\n\n// FIXME: bun doesn't handle unicode characters in code correctly\n// should be able to replace \\u221E with ∞\nconst parseFloatOrInfinity = (x: string): number => {\n  if (x === '-\\u221E') {\n    return -Infinity\n  } else if (x[0] === '\\u221E') {\n    return Infinity\n  } else {\n    return parseFloat(x)\n  }\n}\n\nconst inRange = (spec: string, x: number): boolean => {\n  let lower: string, upper: string\n  if (spec === undefined) return true\n  try {\n    // @ts-expect-error\n    [, lower, upper] = spec.match(/^([[(]-?[\\d.\\u221E]+)?,?(-?[\\d.\\u221E]+[\\])])?$/)\n  } catch (e) {\n    throw new Error(`bad range ${spec}`)\n  }\n  if (lower !== undefined && lower !== '') {\n    const min = parseFloatOrInfinity(lower.substring(1))\n    if (lower[0] === '(') {\n      if (x <= min) return false\n    } else {\n      if (x < min) return false\n    }\n  }\n  if (upper !== undefined && upper !== '') {\n    const max = parseFloatOrInfinity(upper)\n    if (upper.endsWith(')')) {\n      if (x >= max) return false\n    } else {\n      if (x > max) return false\n    }\n  }\n  return true\n}\n\nconst regExps: { [key: string]: RegExp } = {}\n\nconst regexpTest = (spec: string, subject: any): boolean => {\n  const regexp = regExps[spec] !== undefined ? regExps[spec] : regExps[spec] = new RegExp(spec)\n  return regexp.test(subject)\n}\n\nexport const isInstanceOf = (obj: any, constructor: string | Function): boolean => {\n  if (typeof constructor === 'function') {\n    return obj instanceof Function\n  } else {\n    let proto = Object.getPrototypeOf(obj)\n    while (proto.constructor !== undefined && proto.constructor !== Object) {\n      if (proto.constructor.name === constructor) {\n        return true\n      }\n      proto = Object.getPrototypeOf(proto)\n    }\n    return false\n  }\n}\n\nexport const specificTypeMatch = (type: any, subject: any): boolean => {\n  // eslint-disable-next-line\n  const [, optional, baseType, , spec] = type.match(/^#([?]?)([^\\s]+)(\\s(.*))?$/) || []\n  if (optional !== '' && (subject === null || subject === undefined)) return true\n  const subjectType = describe(subject)\n  switch (baseType) {\n    case 'forbidden':\n      return false\n    case 'any':\n      return subject !== null && subject !== undefined\n    case 'native':\n      if (typeof subject !== 'function' || subject.toString() !== 'function () { [native code] }') {\n        return false\n      }\n      if (type == null) {\n        return true\n      }\n      return isAsync(subject) ? type.match(/^async\\b/) : type.match(/^function\\b/)\n    case 'function':\n      if (subjectType !== 'function') return false\n      // todo allow for typeSafe functions with param/result specified by name\n      return true\n    case 'number':\n      if (subjectType !== 'number') return false\n      return inRange(spec, subject)\n    case 'int':\n      if (subjectType !== 'number' || subject !== Math.floor(subject)) return false\n      return inRange(spec, subject)\n    case 'union':\n      return spec.split('||').find((type: string) => specificTypeMatch(`#${type}`, subject)) !== undefined\n    case 'enum':\n      try {\n        return spec.split('|').map(JSON.parse).includes(subject)\n      } catch (e) {\n        throw new Error(`bad enum specification (${spec as string}), expect JSON strings`)\n      }\n    case 'void':\n      return subjectType === 'undefined' || subjectType === 'null'\n    case 'nothing':\n      return subjectType === 'undefined'\n    case 'string':\n      return subjectType === 'string'\n    case 'regexp':\n      return subjectType === 'string' && regexpTest(spec, subject)\n    case 'array':\n      return Array.isArray(subject)\n    case 'instance':\n      return isInstanceOf(subject, spec)\n    case 'promise':\n      return subject instanceof Promise\n    case 'object':\n      return (subject !== null) && typeof subject === 'object' && !Array.isArray(subject)\n    default:\n      if (subjectType !== baseType) {\n        throw makeError('got', subject, `expected \"${type as string}\", \"${subjectType}\" does not match \"${baseType as string}\"`)\n      } else {\n        return true\n      }\n  }\n}\n\nconst functionDeclaration = /^((async\\s+)?function)?\\s*\\((.*?)\\)\\s*(=>)?\\s*\\{/\nconst arrowDeclaration = /^((\\.\\.\\.\\w+)|(\\w+)|\\((.*?)\\))\\s*=>\\s*[^\\s{]/\nconst returnsValue = /\\w+\\s*=>\\s*[^\\s{]|\\breturn\\b/\n\nexport const describeType = (x: any): StringMap | string => {\n  const scalarType = describe(x)\n  switch (scalarType) {\n    case 'array':\n      return x.map(describeType)\n    case 'object':\n      if (x.constructor === Object) {\n        const _type: StringMap = {}\n        Object.keys(x as StringMap).forEach((key) => { _type[key] = describeType(x[key]) })\n        return _type\n      } else {\n        return '#instance x.constructor.name'\n      }\n    case 'function':\n    case 'async':\n    {\n      if (x.protoype !== undefined) {\n        return '#class x.name'\n      }\n      const source = (x as Function).toString()\n      if (source.endsWith('() { [native code] }')) {\n        return `#native ${scalarType}`\n      }\n      const functionSource = source.match(functionDeclaration)\n      const arrowSource = source.match(arrowDeclaration)\n      const hasReturnValue = (source.match(returnsValue) != null) || source.match(arrowDeclaration)\n\n      // eslint-disable-next-line\n      const paramText = ((functionSource && functionSource[3]) ||\n          // eslint-disable-next-line\n          (arrowSource && (arrowSource[2] || arrowSource[3] || arrowSource[4])) || '').trim()\n      const params = paramText.split(',').map((param: string) => {\n        const [key] = param.split('=')\n        return `${key} #any`\n      })\n      return `${scalarType} ( ${params.join(', ')} ) => ${(hasReturnValue != null) ? '#any' : '#nothing'}`\n    }\n    default:\n      return `#${scalarType}`\n  }\n}\n\nexport const typeJSON = (x: any): string => JSON.stringify(describeType(x))\nexport const typeJS = (x: any): string => typeJSON(x).replace(/\"(\\w+)\":/g, '$1:')\n\nconst quoteIfString = (x: any): string => typeof x === 'string' ? `\"${x}\"` : (typeof x === 'object' ? describe(x) : x)\n\n// when checking large arrays, only check a maximum of 111 elements\nfunction * arraySampler (a: any[]): any {\n  let i = 0\n  // 101 is a prime number so hopefully we'll avoid sampling fixed patterns\n  const increment = Math.ceil(a.length / 101)\n  while (i < a.length) {\n    // first five\n    if (i < 5) {\n      yield { sample: a[i], i }\n      i++\n    // last five\n    } else if (i > a.length - 5) {\n      yield { sample: a[i], i }\n      i++\n    } else {\n    // ~1% of the ones in the middle\n      yield { sample: a[i], i }\n      i = Math.min(i + increment, a.length - 4)\n    }\n  }\n}\n\nexport const matchType = (example: any, subject: any, errors: string[] = [], path = ''): string[] => {\n  const exampleType = describe(example)\n  const subjectType = describe(subject)\n  const typesMatch = exampleType.startsWith('#')\n    ? specificTypeMatch(exampleType, subject)\n    : exampleType === subjectType\n  if (!typesMatch) {\n    errors.push(`${path !== '' ? path + ' ' : ''}was ${quoteIfString(subject)}, expected ${exampleType}`)\n  } else if (exampleType === 'array') {\n    // only checking first element of subject for now\n    const sampler = subject.length > 0 ? arraySampler(subject) : false\n    if (example.length === 1 && sampler !== false) {\n      // assume homogenous array\n      for (const { sample, i } of sampler) matchType(example[0], sample, errors, `${path}[${i as number}]`)\n    } else if (example.length > 1 && sampler !== false) {\n      // assume heterogeneous array\n      for (const { sample, i } of sampler) {\n        let foundMatch = false\n        for (const specificExample of example) {\n          if (matchType(specificExample, sample, [], '').length === 0) {\n            foundMatch = true\n            break\n          }\n        }\n        if (!foundMatch) errors.push(`${path}[${i as number}] had no matching type`)\n      }\n    }\n  } else if (exampleType === 'object') {\n    matchKeys(example, subject, errors, path)\n  }\n  return errors\n}\n\nexport const exampleAtPath = (example: any, path: string | string[]): any => {\n  const parts = Array.isArray(path)\n    ? [...path]\n    : path.replace(/\\[[^\\]]*\\]/g, '.*').split('.')\n  if (example === null || example === undefined || parts.length === 0) {\n    return example\n  } else {\n    const part = parts.shift()\n    if (part === '*') {\n      if (Array.isArray(example)) {\n        return example.length === 1\n          ? exampleAtPath(example[0], parts)\n          : exampleAtPath(Object.assign({}, ...example), parts)\n      } else {\n        return undefined\n      }\n    } else {\n      // @ts-expect-error\n      return exampleAtPath(example[part], parts)\n    }\n  }\n}\n\nconst legalVarName = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/\nconst matchKeys = (example: any, subject: any, errors: string[] = [], path = ''): string[] => {\n  const testedKeys = new Set()\n  for (const key of Object.keys(example)) {\n    if (key.startsWith('#')) {\n      let keyTest = legalVarName\n      try {\n        if (key !== '#') {\n          keyTest = new RegExp(`^${key.substring(1)}$`)\n        }\n      } catch (e) {\n        const badKeyError = `illegal regular expression in example key '${key}'`\n        errors.push(badKeyError)\n        throw makeError(badKeyError)\n      }\n      const matchingKeys = Object.keys(subject).filter(key => keyTest.test(key))\n      for (const k of matchingKeys) {\n        if (!testedKeys.has(k)) {\n          matchType(example[key], subject[k], errors, `${path}./^${key.substring(1)}$/:${k}`)\n          testedKeys.add(k)\n        }\n      }\n    } else if (key.endsWith('?')) {\n      const k = key.slice(0, key.length - 1)\n      if (Object.hasOwnProperty.call(subject, k)) {\n        if (!testedKeys.has(k)) {\n          matchType(example[key], subject[k], errors, path + '.' + k)\n          testedKeys.add(k)\n        }\n      }\n    } else {\n      if (!testedKeys.has(key)) {\n        matchType(example[key], subject[key], errors, path + '.' + key)\n        testedKeys.add(key)\n      }\n    }\n  }\n  return errors\n}\n\ninterface TypeErrorConfig {\n  functionName?: string\n  isParamFailure: boolean\n  expected: any\n  found: any\n  errors: string[]\n}\n\nexport class TypeError {\n  // initializers are unnecessary but TypeScript is too stupid\n  functionName: string = 'anonymous'\n  isParamFailure: boolean = false\n  expected: any\n  found: any\n  errors: string[] = []\n\n  constructor (config: TypeErrorConfig) {\n    Object.assign(this, config)\n  }\n\n  toString (): string {\n    const {\n      functionName,\n      isParamFailure,\n      errors\n    } = this\n    return `${functionName}() failed, bad ${isParamFailure ? 'parameter' : 'return'}: ${JSON.stringify(errors)}`\n  }\n}\n\nexport const assignReadOnly = (obj: any, propMap: StringMap): any => {\n  propMap = { ...propMap }\n  for (const key of Object.keys(propMap)) {\n    const value = propMap[key]\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      get () {\n        return value\n      },\n      set (value) {\n        throw new Error(`${key} is read-only`)\n      }\n    })\n  }\n  return obj\n}\n\nexport const matchParamTypes = (types: any[], params: any[]): string[] => {\n  for (let i = 0; i < params.length; i++) {\n    if (params[i] instanceof TypeError) {\n      return params[i]\n    }\n  }\n  const [paramErrors, returnErrors] = types.map((type, i) => matchType(type, params[i]))\n  return [...paramErrors, ...returnErrors]\n}\n\ninterface TypeSafeFunction {\n  (...args: any[]): any\n  paramTypes: any[]\n  resultType: any\n}\n\nexport const typeSafe = (func: Function, paramTypes: any[] = [], resultType: any = undefined, functionName: string = 'anonymous'): TypeSafeFunction => {\n  const paramErrors = matchParamTypes(\n    ['#function', '#?array', '#?any', '#?string'],\n    [func, paramTypes, resultType, functionName]\n  )\n  if (paramErrors instanceof TypeError) {\n    throw new Error('typeSafe was passed bad parameters')\n  }\n\n  if (func.name !== '') {\n    functionName = func.name\n  }\n  let callCount = 0\n  return assignReadOnly(function (...params: any[]) {\n    callCount += 1\n    const paramErrors = matchParamTypes(paramTypes, params)\n    // short circuit failures\n    if (paramErrors instanceof TypeError) return paramErrors\n\n    if (paramErrors.length === 0) {\n      const result = func(...params)\n      const resultErrors = matchType(resultType, result)\n      if (resultErrors.length === 0) {\n        return result\n      } else {\n        return new TypeError({\n          functionName,\n          isParamFailure: false,\n          expected: resultType,\n          found: result,\n          errors: resultErrors\n        })\n      }\n    }\n    return new TypeError({\n      functionName,\n      isParamFailure: true,\n      expected: paramTypes,\n      found: params,\n      errors: paramErrors\n    })\n  }, {\n    paramTypes,\n    resultType,\n    getCallCount: () => callCount\n  })\n}\n","const stringify = (x: any): string => {\n  try {\n    return JSON.stringify(x)\n  } catch (_) {\n    return '{has circular references}'\n  }\n}\n\nexport const makeError = (...messages: any[]): Error => new Error(messages.map(stringify).join(' '))\n"],"names":[],"version":3,"file":"index.js.map"}